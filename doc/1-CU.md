# Control Unit #

The control unit generates most of the signals that drive the execution of each instruction, with the exception of some additional signals, which are occasionally generated by two separate hardware blocks to handle a few particular cases and provide advanced functionalities (decentralized control).

Namely, two other units sometimes contribute to driving the datapath in addition to the CU:
- the Forwarder block implements operand forwarding: it transparently takes care of solving Data Hazard cases, by detecting Read-After-Write hazards and overriding the operands selected by the CU with the ALU's latest results; note that, since the architecture is not superscalar, only RAW hazards (and not WAR or WAW hazards) need to be taken into consideration.
- the Fetch Stage, apart from performing regular instruction fetching, also checks each new instruction, and contributes to drive the datapath for some particular instructions (e.g. if the instruction is a JR, it selects register r0 as source in the register file, since this is not hard-coded in the corresponding instruction, and the CU doesn't explicitly drive the register file's address inputs).

This approach allows the CU to give a simpler interpretation to the content of the Instruction Register for each new instruction (for example, the contents of the RS1, RS2, RD fields of each instruction are directly routed towards the register file, and the CU doesn't have to keep track of the last 2 instructions to detect data hazards; if necessary, the Forwarder block will transparently substitute the "stale" values coming from the RF with the updated results coming directly from the ALU output).


The control unit has a Hardwired topology: functionally, it's composed of a big lookup table, which matches the content of the IR and outputs the corresponding control signals, and a number of pipe registers depending on the number of stages in the architecture's pipeline (in this case, the DLX architecture has a 5-stage pipeline following the CU, so 4 pipe registers are used); the control word for a given instruction is generated all at once using the lookup table, and then the pipe registers are responsible for correctly shifting each portion of the control word to the corresponding pipeline stage and with a certain delay; this makes the instruction "travel" along the pipeline with the right timing.

In order to make it easy to scale and maintain its code, the CU has been implemented as a "tree" that, in general, gradually matches the instruction piece by piece and generates control signals as it proceeds (from a hardware perspective, this is equivalent to a tree of multiplexers).
For example, let's suppose the current instruction is an ADDUI: first, the instruction type will be identified (I-type instruction), and the control signals that are common to all I-type instructions will be generated (e.g. select the IMM field of the Instruction Register as second operand for the ALU); then, the instruction will be fit into some "sub-type" (in this case, an I-type arithmetic instruction) and the signals common to all I-type arithmetic instructions will be generated (e.g. select the result coming from the Arithmetic Unit as the ALU output); possibilities are progressively narrowed, as the last bits of the Instruction Register are examined, and signals specific to the exact instruction (in this case, ADDUI => select unsigned extension for the 16-bit immediate value, tell the Arithmetic Unit to perform addition, etc.)

![Instruction set of the CPU, with the choice tree the CU evaluates to generate the control word](./Instruction_set.pdf)
