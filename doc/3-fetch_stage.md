# Fetch-stage architecture #
The fetch stage takes care of automatically managing the program counter (and nothing more).


Its work is based on an accumulator (PC\_ACC) which can, at each clock cycle, either add 4 to the PC (if ACC\_ENABLE==1, ACC\_JMP=0, OVERWRITE=0), or add an immediate value (26 bits, sign-extended to 32) to the PC (ACC\_ENABLE==1, ACC\_JMP=1, OVERWRITE=0), or change the current PC value (OVERWRITE=1), or do nothing (ACC\_ENABLE=0).
The BPU is the main responsible for managing the ACC\_JMP signal, which is - almost - hardwired to its "PREDICTION" signal: in case of a normal operation, PREDICTION==0 and the accumulation goes on; in case of a jmp, PREDICTION==1 if either the jump is unconditioned or the branch is predicted as taken.


The PREDICTION signal is feed both to the PC\_ACC (which will take the jumps) and to a flag-checker unit: as soon as a branch is executed (doesn't matter if it is taken or not), the CU takes care of computing the address which will overwrite the current PC in case it was mispredicted.
The prediction is saved inside the fetch unit and delayed for 3 clock cycles, which is the time at which the fallback address will exit the Datapath's ALU.

Also, the CU will send the register on which the branch is checked to the CHECK\_REGISTER input of the FETCH\_STAGE. Coming from the Datapath, this output has forwarding enabled too, and thus corresponds to the real value the register should have at the moment of branching.

When the register's value, together with the fallback address, enters the datapath, the fetch stage checks the prediction (which is delayed together with a NO\_CHECK signal in case the instruction was not a branch) and, if it has been wrong, activates the "had\_wrong\_prediction" signal. This one goes directly to OVERWRITE, so that the PC\_ACC will change its address with the real one, and to a FLUSH\_UNIT.

The FLUSH\_UNIT has a very simple structure and is responsible for driving a FLUSH signal into the CU pipeline registers, in order to transform the 3 instructions entering the ALU (the ones which were wrongly fetched) into 3 NOP instructions. The same FLUSH signal acts as a gate for the NO\_CHECK signals generated by the wrongly fetched instructions, so that if branches have been fetched - and mispredicted - by mistake, they will not generate other flushes or PC overwrites.

JR operations are a special case, as they are always predicted as not taken and then always taken; in this way, the CPU has the time to read the register content (and to apply forwarding to it if necessary), and the register value will be used as a fallback\_address and will do the jump. Another special flag FORCE\_WRONG is used for this purpose, and it can be bypassed by a previously generated OVERWRITE.

To apply a correct forwarding of data without too much overhead on the datapath, the only special case to handle is the one in which a LOAD operation is done and, in the next instruction, the loaded register is used into the ALU. In this case, the register's future content has not yet been read when the instruction enters the ALU, and thus this situation is not manageable from the forwarding unit. So, the fetch stage keeps track of the previous instruction and, in case it was a load on a register used into the current one, it bypasses the IR with a NOP and disables the ACC\_ENABLE line of the accumulator; by doing this, a bubble is introduced into the pipeline and the load-read situation never gets to the datapath. This ensures a correct operation of forwarding in a transparent manner.

